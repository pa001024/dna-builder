# 琳恩技能实现文档

## 角色基础信息
- **角色名称**: 琳恩
- **属性**: 火属性
- **武器精通**: 重剑/双枪
- **同律武器**: 汉塞尔与格雷特

## 技能机制

### 1. 致命绽放 (E技能)

#### 技能描述
对前方大范围敌人造成火属性伤害并附加[裂伤]效果。

#### 实现要点
- 类型：范围伤害技能 (AREA)
- 神智消耗：12（受效益属性影响）
- 伤害半径：20米
- 基础伤害：1.96-6.69（随等级提升）
- [裂伤]效果：
  - 持续时间：8秒
  - 基础伤害：0.66-2.2（随等级提升）
  - 裂伤创口计数：10层
- 需要实现裂伤持续伤害系统
- 需要实现创口计数机制
- 所有数值从LeveledSkill获取

---

### 2. 火药酬宾 (Q技能)

#### 技能描述
进入持续射击状态，消耗神智对敌人造成范围伤害，攻击速度随层数提升。

#### 实现要点
- 类型：持续施法技能 (CHANNEL)
- 初始神智消耗：10（受效益属性影响）
- 每秒神智消耗：20（受效益和耐久属性影响）
- 射击伤害：1.27-2.81（随等级提升）
- 最大范围：50米
- 每层攻击速度提高：3%
- 需要实现持续射击机制
- 需要实现层数累积系统
- 需要实现范围可变的射击效果
- 所有数值从LeveledSkill获取

---

### 3. 战术速射 (被动技能)

#### 技能描述
根据射击层数提升伤害，并在特定条件下进入[火力压制]状态。

#### 实现要点
- 类型：被动技能 (PASSIVE)
- [火力压制]状态持续时间：6秒（受耐久属性影响）
- 每层伤害提高：5.1%-17.2%（随等级提升）
- 需要实现层数累积系统
- 需要实现[火力压制]状态管理
- 需要监听射击事件
- 所有数值从LeveledSkill获取

---

## 根源能力

根据buff.data.ts中的数据，琳恩有以下根源能力：

| 名称 | 效果 |
|------|------|
| 琳恩裂伤特性 | 裂伤相关特性增强 |
| 琳恩愤怒 | 愤怒状态相关 |
| 琳恩？？？ | 未知特殊效果 |
| 琳恩敬礼 | 敬礼状态相关 |

---

## 数据获取方式

### LeveledSkill数据结构
- 技能等级：从LeveledSkill获取
- 伤害倍率：从LeveledSkill获取
- 神智消耗：从LeveledSkill获取
- 状态持续时间：从LeveledSkill获取
- 范围数值：从LeveledSkill获取

### CharBuild.calculateAttributes
- 基础属性：攻击288.7、生命1318、护盾1318、防御240、神智150
- 攻击：0.5
- 耐久：0.15
- 效益：影响神智消耗

---

## AI实现建议

### 核心系统
1. **裂伤系统**: 需要实现裂伤持续伤害和创口计数机制
2. **持续射击系统**: 需要实现火药酬宾的持续射击和层数累积
3. **层数系统**: 需要实现攻击速度和伤害提升的层数机制
4. **火力压制系统**: 需要实现特殊状态的管理和效果

### 技能实现优先级
1. **致命绽放**: 基础范围伤害技能，需要实现裂伤系统
2. **火药酬宾**: 持续施法技能，需要实现射击和层数系统
3. **战术速射**: 被动技能，需要实现层数累积和火力压制

### 数值平衡建议
- 所有数值从LeveledSkill和CharBuild.calculateAttributes动态获取
- 实现技能等级系统，使技能效果随等级提升
- 平衡裂伤的持续伤害和即时伤害
- 考虑持续射击的层数累积速度和上限

---

## 特殊机制

### 裂伤系统实现
```typescript
// 裂伤效果管理
interface BleedWound {
    target: any
    endTime: number
    stackCount: number
    baseDamage: number
}

private bleedWounds = new Map<any, BleedWound>()

private applyBleedWound(state: GameState, target: any): void {
    const existingWound = this.bleedWounds.get(target)
    const baseDamage = this.getFieldValue("[裂伤]基础伤害")
    const duration = this.getFieldValue("[裂伤]持续时间") * 1000
    const maxStacks = this.getFieldValue("[裂伤创口]计数")
    
    if (existingWound && Date.now() < existingWound.endTime) {
        // 刷新持续时间，增加层数
        existingWound.endTime = Date.now() + duration
        existingWound.stackCount = Math.min(existingWound.stackCount + 1, maxStacks)
    } else {
        // 新建裂伤
        this.bleedWounds.set(target, {
            target,
            endTime: Date.now() + duration,
            stackCount: 1,
            baseDamage
        })
    }
}

private processBleedDamage(state: GameState): void {
    const now = Date.now()
    for (const [target, wound] of this.bleedWounds.entries()) {
        if (now <= wound.endTime) {
            const totalDamage = wound.baseDamage * wound.stackCount
            this.applyDamage(state, target, totalDamage)
        } else {
            this.bleedWounds.delete(target)
        }
    }
}
```

### 层数累积系统
```typescript
// 射击层数管理
interface FirepowerStack {
    count: number
    lastUpdateTime: number
    attackSpeedBonus: number
    damageBonus: number
}

private firepowerStacks: FirepowerStack = {
    count: 0,
    lastUpdateTime: 0,
    attackSpeedBonus: 0,
    damageBonus: 0
}

private addFirepowerStack(): void {
    this.firepowerStacks.count++
    this.firepowerStacks.lastUpdateTime = Date.now()
    
    const attackSpeedPerStack = this.getFieldValue("每层攻击速度提高")
    const damagePerStack = this.getFieldValue("每层的伤害提高")
    
    this.firepowerStacks.attackSpeedBonus = this.firepowerStacks.count * attackSpeedPerStack
    this.firepowerStacks.damageBonus = this.firepowerStacks.count * damagePerStack
}

private checkSuppressionState(state: GameState): void {
    const playerState = state.player as any
    const duration = this.getFieldValue("火力压制持续时间") * 1000
    
    if (this.firepowerStacks.count >= 5) { // 假设5层进入火力压制
        playerState.inSuppressionState = true
        playerState.suppressionEndTime = Date.now() + duration
    }
}

private calculateEnhancedDamage(baseDamage: number): number {
    const leveledSkill = this.getLeveledSkill()
    const bonusPerStack = this.getFieldValue("每层的伤害提高")
    
    return baseDamage * (1 + (this.firepowerStacks.count * bonusPerStack))
}
```

### 范围可变射击
```typescript
// 动态范围计算
private calculateDynamicRange(): number {
    const baseRange = 10 // 基础范围
    const maxRange = this.getFieldValue("最大范围")
    
    // 根据层数计算范围，层数越多范围越大
    const rangeIncrease = Math.min(this.firepowerStacks.count * 2, maxRange - baseRange)
    return baseRange + rangeIncrease
}

private performVariableRangeShot(state: GameState, playerPosition: { x: number; y: number }): void {
    const range = this.calculateDynamicRange()
    const direction = this.calculateShotDirection(state, playerPosition)
    
    // 根据范围计算伤害衰减
    const targets = this.getTargetsInRange(state, playerPosition, range)
    targets.forEach(target => {
        const distance = this.calculateDistance(playerPosition, target.position)
        const damageMultiplier = Math.max(0.3, 1 - (distance / range) * 0.7) // 最少30%伤害
        const damage = this.calculateDamage() * damageMultiplier
        
        this.applyDamage(state, target, damage)
    })
}
```