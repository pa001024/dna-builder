# 赛琪技能实现文档

## 角色基础信息
- **角色名称**: 赛琪
- **属性**: 风属性
- **武器精通**: 长柄/突击枪
- **同律武器**: 伊卡洛斯

## 技能机制

### 1. 抽茧成梦/逐光 (E技能)

#### 技能描述
根据当前状态释放不同技能：
- **抽茧成梦**: 释放幻象，对范围内敌人造成风属性伤害并降低移动速度
- **逐光**: 释放浮光鳞粉，对敌人造成伤害并附加鳞粉印记

#### 实现要点
- 类型：伤害技能 (INSTANT/AREA)
- 神智消耗：30（受效益属性影响）
- 双状态切换机制
- 抽茧成梦状态：
  - 幻象伤害半径：6米
  - 移动速度降低：20%
  - 伤害倍率：0.681-2.342（随等级提升）
- 逐光状态：
  - 浮光鳞粉伤害：0.424-1.458（随等级提升）
  - 鳞粉印记触发伤害：0.127-0.424（随等级提升）
  - 鳞粉印记持续时间：10秒
- 需要实现印记系统
- 所有数值从LeveledSkill获取

---

### 2. 腐草为萤 (Q技能)

#### 技能描述
进入持续射击状态，消耗神智对敌人造成伤害，同时消耗生命值。

#### 实现要点
- 类型：持续施法技能 (CHANNEL)
- 初始神智消耗：10（受效益属性影响）
- 每秒神智消耗：30（受效益和耐久属性影响）
- 射击伤害：0.664-1.478（随等级提升）
- 射击伤害半径：3米
- 每秒流失生命值：5%最大生命
- 超限护盾转化比例：150%
- 需要实现持续射击机制
- 需要实现生命值消耗和护盾转化
- 所有数值从LeveledSkill获取

---

### 3. 萤烛微光 (被动技能)

#### 技能描述
根据当前增益效果数量提升自身属性，并在特定条件下触发[破茧]状态。

#### 实现要点
- 类型：被动技能 (PASSIVE)
- 基础属性提升：
  - 攻击提高：7.9%-28.8%（随等级提升）
  - 技能威力提高：7.9%-28.8%（随等级提升）
  - 背水提高：3.7%-11.4%（随等级提升）
- 持续时间：10秒（受耐久属性影响）
- 每个增益效果伤害提高：1.2%-3.4%（随等级提升）
- 需要实现增益效果计数系统
- 需要实现[破茧]状态机制
- 所有数值从LeveledSkill获取

---

## 根源能力

根据buff.data.ts中的数据，赛琪有以下根源能力：

| 名称 | 效果 |
|------|------|
| 赛琪被动 | 基础被动效果 |
| 赛琪1塑 | 第一塑像效果 |
| 赛琪6塑 | [破茧]状态中自身全属性穿透提高50.0% |

---

## 数据获取方式

### LeveledSkill数据结构
- 技能等级：从LeveledSkill获取
- 伤害倍率：从LeveledSkill获取
- 神智消耗：从LeveledSkill获取
- 状态持续时间：从LeveledSkill获取
- 范围数值：从LeveledSkill获取

### CharBuild.calculateAttributes
- 基础属性：攻击351.46、生命879、护盾1757、防御252、神智150
- 威力：0.2
- 背水：0.05
- 效益：影响神智消耗

---

## AI实现建议

### 核心系统
1. **双状态系统**: 需要实现抽茧成梦/逐光状态切换机制
2. **印记系统**: 需要实现鳞粉印记的附加、触发和持续管理
3. **持续射击系统**: 需要实现腐草为萤的持续射击和资源消耗
4. **增益计数系统**: 需要实现增益效果计数和属性提升机制

### 技能实现优先级
1. **抽茧成梦/逐光**: 基础伤害技能，需要实现双状态和印记系统
2. **腐草为萤**: 持续施法技能，需要实现射击和资源管理
3. **蜡烛微光**: 被动技能，需要实现增益计数和属性提升

### 数值平衡建议
- 所有数值从LeveledSkill和CharBuild.calculateAttributes动态获取
- 实现技能等级系统，使技能效果随等级提升
- 平衡双状态的伤害和效果差异
- 考虑持续射击的资源消耗平衡

---

## 特殊机制

### 印记系统实现
```typescript
// 鳞粉印记管理
interface ScalePowderMark {
    target: any
    endTime: number
    damage: number
}

private scalePowderMarks = new Map<any, ScalePowderMark>()

private applyScalePowderMark(state: GameState, target: any): void {
    const damage = this.getFieldValue("[鳞粉印记]触发伤害")
    const duration = this.getFieldValue("[鳞粉印记]持续时间") * 1000
    
    this.scalePowderMarks.set(target, {
        target,
        endTime: Date.now() + duration,
        damage
    })
}

private triggerScalePowderDamage(state: GameState): void {
    const now = Date.now()
    for (const [target, mark] of this.scalePowderMarks.entries()) {
        if (now <= mark.endTime) {
            this.applyDamage(state, target, mark.damage)
        }
    }
}
```

### 增益计数系统
```typescript
// 增益效果计数
private calculateBuffCount(state: GameState): number {
    const playerState = state.player as any
    const buffs = playerState.activeBuffs || []
    return buffs.length
}

private calculateAttributeBonus(): { attack: number, power: number, backwater: number } {
    const buffCount = this.calculateBuffCount(state)
    const leveledSkill = this.getLeveledSkill()
    
    const baseAttack = this.getFieldValue("攻击提高")
    const basePower = this.getFieldValue("技能威力提高")
    const baseBackwater = this.getFieldValue("背水提高")
    const buffBonus = this.getFieldValue("每个增益效果令造成的伤害提高")
    
    return {
        attack: baseAttack + (buffCount * buffBonus),
        power: basePower + (buffCount * buffBonus),
        backwater: baseBackwater
    }
}
```

### 超限护盾转化
```typescript
// 护盾转化机制
private convertExcessShieldToDamage(damage: number): number {
    const playerState = state.player as any
    const currentShield = playerState.shield || 0
    const maxShield = playerState.maxShield || 0
    
    if (currentShield >= maxShield) {
        const conversionRate = this.getFieldValue("超限护盾转化比例")
        return damage * (1 + conversionRate)
    }
    
    return damage
}
```